---
title: 'HTTP发展史'
date: 2023-06-19 08:33:00
category:
  - 面试
tag:
  - 计算机网络
star: true
article: true
---

::: tip 省流总结
### http1.0和http1.1
1. HTTP1.0默认是`短连接`，每次与服务器交互，都需要新开一个TCP连接；  
   HTTP1.1默认是`长连接`。只要客户端服务端没有断开TCP连接，就一直保持连接，可以发送多次HTTP请求。(目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接)
2. http1.1支持`断点续传`，只发送header信息（不带任何body信息）
3. http1.0缓存处理：expires，http1.1引入更丰富的缓存字段如：cache-control

### http1.1和http2.0
1. http1.1需要等上一个请求的响应数据回来后才能发送另一个请求；  
   http2.0多路复用，同一个TCP连接并发处理多个请求；
2. http1.1请求头header以纯文本传输；http2.0支持`头部压缩`
3. http2.0支持`服务端推送`

### http2.0和http3.0
1. http3.0弃用tcp，使用udp，提高连接速度
2. 彻底解决队头拥塞，http2.0多个请求一个tcp管道，http3.0同一个物理连接多个独立的数据流
:::

[解读 HTTP1/HTTP2/HTTP3](https://juejin.cn/post/6995109407545622542)
 
[一文总结http1.0，http1.1，http2，http3，面试强心剂](https://juejin.cn/post/7001510315514937375)

## HTTP/0.9

HTTP 的最早版本诞生在 1991 年。这个最早版本和现在比起来极其简单，没有 HTTP 头，没有状态码，甚至版本号也没有，后来它的版本号才被定为 0.9 来和其他版本的 HTTP 区分。HTTP/0.9 只支持一种方法—— Get，请求只有一行。

## HTTP/1.0

HTTP1.0最早在网页中使用是在1996年。随着新兴网络发展，首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。服务器不知道如文件编码、文件类型，因此直接返回数据给浏览器...为了满足传输多种类型文件的需求，http1.0引入了`请求头` 和 `响应头`

## HTTP/1.1

### http1.1在http1.0上的改进

#### :blush:改进持久连接

HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。如果一个页面包含了几百个外部引用的资源文件，在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。  

为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。  

持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前谷歌浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。  

#### :blush:不成熟的 HTTP 管线化

持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞(应用层)的问题。  

HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞  

FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

3. 提供虚拟主机的支持
4. 对动态生成的内容提供了完美支持
5. 客户端 Cookie、安全机制
6. 断掉续传
要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头 Range和Content-Range字段，一个最简单的断点续传实现大概如下：   1.客户端下载一个1024K的文件，已经下载了其中512K   2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：        Range:bytes=512000-     这个头通知服务端从文件的512K位置开始传输文件   3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-/1024000     并且此时服务端返回的HTTP状态码应该是206，而不是200。
​http1.1 性能瓶颈
1. 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大(只能压缩 Body 的部分)；
2. 响应头的对头阻塞没有彻底解决；
3. 没有请求优先级控制；
4. 请求只能从客户端开始，服务器只能被动响应。

## HTTP/2.0

      
    http2.0
      1. 多路复用
      a. 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
      b. 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
      c. 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
      d. 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
      e. 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
      f. 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求
      通过二进制分帧层将请求转成一个个带有ID编号的帧，经过服务器处理后，二进制分帧层又将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器，浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
      
      1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；
      Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
      Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；
      因此，我们可以得出个结论：多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。
      HTTP/2 通过 Stream 实现的并发，比 HTTP/1.1 通过 TCP 连接实现并发要牛逼的多，因为当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。
      HTTP/2 还可以对每个 Stream 设置不同优先级，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。
      
      与http1.1管线化的区别：
      HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
      HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。
      (使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据；而HTTP/2.0是一个TCP连接的，所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好)
      2. 头部压缩
      使用了HPACK 算法进行Headers头部压缩
      3.  二进制帧
      HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。
      4.服务器推送
      http2让服务器可以将响应数据主动“推送”到客户端缓存中
      
      缺点：主要是底层的tcp协议造成的
      1.TCP 的队头阻塞并没有彻底解决
      因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。
      2.TCP 以及 TCP+TLS 建立连接的延时
      网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。

      我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。

在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍
总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。

## HTTP/3.0



    http3.0
      http3就是为了解决http2相关问题而诞生，它基于一个新的传输层协议QUIC，而http3就是建立一个在QUIC上运行的HTTP新规范，而http3之前的版本都是基于TCP，QUIC就是为了替代TCP，解决TCP的一些缺陷
      tcp缺陷：
      1.不支持流级复用，TCP会将所有对象序列化在同一个流中，因此，它不知道TCP段的对象级分区，无法在同一个流中复用数据包
      2.会产生冗余通信，tco三次连接握手会有冗余的消息交换序列
      3.可能会间歇性地挂起数据传输，tcp中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞
      quic：
      1.同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率
      2.放弃tcp，通过udp建立（无连接），提高了连接建立的速度，降低了延迟
      3.tcp本身是无法解决队头拥塞，quic则解决了这个问题
      4.Connection ID使得http3支持连接迁移以及NAT的重绑定
      

