import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,f as r}from"./app-033cd4d2.js";const t={},o=r('<h2 id="对promise的理解" tabindex="-1"><a class="header-anchor" href="#对promise的理解" aria-hidden="true">#</a> 对Promise的理解</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>Promise 对象是异步编程的一种解决方案。Promise 是一个构造函数，接收一个函数（executor）作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是pending、fulfilled和rejected，分别代表了进行中、已成功和已失败， 实例的状态只能由 pending 转变 fulfilled 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变。 状态改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态， 它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br> 注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ol><li>状态不受外界影响，只受异步操作的结果来决定</li><li>一旦状态改变，任何时候都可以得到这个结果</li></ol><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ol><li>无法取消promise，一旦新建它就会立即执行，无法中途取消</li><li>如果不设置回调函数，promise内部抛出的错误，不会反应到外部</li><li>当处于padding状态时，无法得知具体哪个阶段（刚开始/即将完成）</li></ol><h3 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法" aria-hidden="true">#</a> 静态方法</h3><ul><li>Promise.all 所有成功才执行then，有一个失败后面都会被忽略并执法catch</li><li>Promise.race 拿到最快的看是then还是catch</li><li>Promise.allSettled 所有执行完毕，返回包含了每个promise结果的对象数组 [{ status: &quot;fulfilled&quot;, value: 3 }, { status: &quot;rejected&quot;, reason: &quot;foo&quot; }]</li><li>Promise.any 有成功就执行then，输出第一个成功的，所有失败才执行catch ES2021</li></ul><h2 id="对async-await的理解" tabindex="-1"><a class="header-anchor" href="#对async-await的理解" aria-hidden="true">#</a> 对async/await的理解</h2><p>async/await其实是 Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then的回调地狱而开发出来的。</p>',11),l=[o];function s(h,n){return a(),i("div",null,l)}const u=e(t,[["render",s],["__file","异步编程.html.vue"]]);export{u as default};
