const e=JSON.parse('{"key":"v-4cd09d74","path":"/technology/REACT/react.html","title":"react知识","lang":"zh-CN","frontmatter":{"title":"react知识","category":["面试"],"tag":["REACT"],"star":false,"sticky":false,"article":true,"description":"与vue相比 相同点 都使用虚拟DOM提高性能 专注自身核心库，将其他功能如路由和全局状态管理交给其他库 都提倡组件化，提高复用性 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板 都有props的概念，允许组件间的数据传递 不同的 语法 vue-SFC模板系统，接近html写法、react-JSX语法 数据绑定 vue-v-model双向绑定、react-setState单向流动 监听数据变化的原理 vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化 vue 计算 Virtual DOM 的差异是以组件为颗粒度的，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 react 默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的 VDOM 的重新渲染。 可以用 shouldComponentUpdate/PureComponent/React.memo() 进行优化 条件渲染 vue-v-if、react-借助三元运算符，逻辑性更强 组件通信 vue 子组件向父组件发送消息有两种方式：事件(emit)和回调函数(定义在props) vue 通过 provide/inject 来实现跨层级的通信 react 子组件向父组件发送消息，都是使用回调函数的 react 可以通过 context 进行跨层级的通信 css模块作用域 vue-scoped、react-module(xxx.module.css)","head":[["meta",{"property":"og:url","content":"https://leoleor.github.io/Lion_Blog/technology/REACT/react.html"}],["meta",{"property":"og:site_name","content":"一只攻城狮"}],["meta",{"property":"og:title","content":"react知识"}],["meta",{"property":"og:description","content":"与vue相比 相同点 都使用虚拟DOM提高性能 专注自身核心库，将其他功能如路由和全局状态管理交给其他库 都提倡组件化，提高复用性 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板 都有props的概念，允许组件间的数据传递 不同的 语法 vue-SFC模板系统，接近html写法、react-JSX语法 数据绑定 vue-v-model双向绑定、react-setState单向流动 监听数据变化的原理 vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化 vue 计算 Virtual DOM 的差异是以组件为颗粒度的，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 react 默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的 VDOM 的重新渲染。 可以用 shouldComponentUpdate/PureComponent/React.memo() 进行优化 条件渲染 vue-v-if、react-借助三元运算符，逻辑性更强 组件通信 vue 子组件向父组件发送消息有两种方式：事件(emit)和回调函数(定义在props) vue 通过 provide/inject 来实现跨层级的通信 react 子组件向父组件发送消息，都是使用回调函数的 react 可以通过 context 进行跨层级的通信 css模块作用域 vue-scoped、react-module(xxx.module.css)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-05T14:03:40.000Z"}],["meta",{"property":"article:author","content":"狮子"}],["meta",{"property":"article:tag","content":"REACT"}],["meta",{"property":"article:modified_time","content":"2025-03-05T14:03:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"react知识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-05T14:03:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"狮子\\"}]}"]]},"headers":[{"level":2,"title":"与vue相比","slug":"与vue相比","link":"#与vue相比","children":[]},{"level":2,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":2,"title":"JSX语法","slug":"jsx语法","link":"#jsx语法","children":[]},{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[]},{"level":2,"title":"组件实例的三大属性","slug":"组件实例的三大属性","link":"#组件实例的三大属性","children":[{"level":3,"title":"state","slug":"state","link":"#state","children":[]},{"level":3,"title":"props","slug":"props","link":"#props","children":[]},{"level":3,"title":"ref","slug":"ref","link":"#ref","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"旧版","slug":"旧版","link":"#旧版","children":[]},{"level":3,"title":"新版","slug":"新版","link":"#新版","children":[]}]}],"git":{"createdTime":1694523150000,"updatedTime":1741183420000,"contributors":[{"name":"狮子","email":"hzr1642921219@163.com","commits":2}]},"readingTime":{"minutes":2.69,"words":808},"filePathRelative":"technology/REACT/react.md","localizedDate":"2023年9月12日","excerpt":"<h2> 与vue相比</h2>\\n<ul>\\n<li>\\n<p>相同点</p>\\n<ol>\\n<li>都使用虚拟DOM提高性能</li>\\n<li>专注自身核心库，将其他功能如路由和全局状态管理交给其他库</li>\\n<li>都提倡组件化，提高复用性</li>\\n<li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板</li>\\n<li>都有props的概念，允许组件间的数据传递</li>\\n</ol>\\n</li>\\n<li>\\n<p>不同的</p>\\n<ol>\\n<li><code>语法</code> vue-SFC模板系统，接近html写法、react-JSX语法</li>\\n<li><code>数据绑定</code> vue-v-model双向绑定、react-setState单向流动</li>\\n<li><code>监听数据变化的原理</code></li>\\n</ol>\\n<ul>\\n<li>vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化</li>\\n<li>vue 计算 Virtual DOM 的差异是以组件为颗粒度的，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>\\n<li>react 默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的 VDOM 的重新渲染。\\n可以用 <code>shouldComponentUpdate/PureComponent/React.memo()</code> 进行优化</li>\\n</ul>\\n<ol start=\\"4\\">\\n<li><code>条件渲染</code> vue-v-if、react-借助三元运算符，逻辑性更强</li>\\n<li><code>组件通信</code></li>\\n</ol>\\n<ul>\\n<li>vue 子组件向父组件发送消息有两种方式：事件(emit)和回调函数(定义在props)</li>\\n<li>vue 通过 provide/inject 来实现跨层级的通信</li>\\n<li>react 子组件向父组件发送消息，都是使用回调函数的</li>\\n<li>react 可以通过 context 进行跨层级的通信</li>\\n</ul>\\n<ol start=\\"6\\">\\n<li><code>css模块作用域</code> vue-scoped、react-module(xxx.module.css)</li>\\n</ol>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
