const e=JSON.parse('{"key":"v-ff77ed92","path":"/technology/VUE2/router.html","title":"vue路由","lang":"zh-CN","frontmatter":{"title":"vue路由","category":["面试","知识点"],"tag":["VUE","路由"],"star":false,"sticky":false,"article":true,"description":"前言 传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。 前端路由 你对前端路由/vue-router的理解？ 前端路由/vue-router的实现原理？ 前端路由是基于hash模式和history模式实现的。 hash模式是通过监听浏览器的hashchange事件，当浏览器hash值（锚点#）部分发生变化，做出相应渲染。 优点：1.兼容性好，大部分浏览器都支持；2.不需要后端配合 缺点：1.外观上带#号；2.影响seo搜索 history模式是使用html5推出的historyAPI，使用popstate来监听变化，pushState和replaceState来实现渲染。 优点：1.有更符合浏览器链接的外观；2.利于seo搜索 缺点：1.兼容性较差；2.需要后端配合，非则可能出现404错误","head":[["meta",{"property":"og:url","content":"https://leoleor.github.io/Lion_Blog/technology/VUE2/router.html"}],["meta",{"property":"og:site_name","content":"一只攻城狮"}],["meta",{"property":"og:title","content":"vue路由"}],["meta",{"property":"og:description","content":"前言 传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。 前端路由 你对前端路由/vue-router的理解？ 前端路由/vue-router的实现原理？ 前端路由是基于hash模式和history模式实现的。 hash模式是通过监听浏览器的hashchange事件，当浏览器hash值（锚点#）部分发生变化，做出相应渲染。 优点：1.兼容性好，大部分浏览器都支持；2.不需要后端配合 缺点：1.外观上带#号；2.影响seo搜索 history模式是使用html5推出的historyAPI，使用popstate来监听变化，pushState和replaceState来实现渲染。 优点：1.有更符合浏览器链接的外观；2.利于seo搜索 缺点：1.兼容性较差；2.需要后端配合，非则可能出现404错误"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-11T09:20:34.000Z"}],["meta",{"property":"article:author","content":"狮子"}],["meta",{"property":"article:tag","content":"VUE"}],["meta",{"property":"article:tag","content":"路由"}],["meta",{"property":"article:modified_time","content":"2025-03-11T09:20:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue路由\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-11T09:20:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"狮子\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"前端路由","slug":"前端路由","link":"#前端路由","children":[{"level":3,"title":"模式","slug":"模式","link":"#模式","children":[]},{"level":3,"title":"区别","slug":"区别","link":"#区别","children":[]}]},{"level":2,"title":"$router 和 $route","slug":"router-和-route","link":"#router-和-route","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"属性","slug":"属性","link":"#属性","children":[{"level":4,"title":"$router","slug":"router","link":"#router","children":[]},{"level":4,"title":"$route","slug":"route","link":"#route","children":[]}]},{"level":3,"title":"方法","slug":"方法","link":"#方法","children":[{"level":4,"title":"$router","slug":"router-1","link":"#router-1","children":[]}]}]},{"level":2,"title":"路由钩子","slug":"路由钩子","link":"#路由钩子","children":[]},{"level":2,"title":"路由组件","slug":"路由组件","link":"#路由组件","children":[]},{"level":2,"title":"路由懒加载","slug":"路由懒加载","link":"#路由懒加载","children":[]},{"level":2,"title":"动态路由","slug":"动态路由","link":"#动态路由","children":[{"level":3,"title":"前端控制","slug":"前端控制","link":"#前端控制","children":[]},{"level":3,"title":"后端控制","slug":"后端控制","link":"#后端控制","children":[]}]},{"level":2,"title":"浏览器跳转和路由跳转","slug":"浏览器跳转和路由跳转","link":"#浏览器跳转和路由跳转","children":[]}],"git":{"createdTime":1741597295000,"updatedTime":1741684834000,"contributors":[{"name":"狮子","email":"hzr1642921219@163.com","commits":2}]},"readingTime":{"minutes":4.97,"words":1492},"filePathRelative":"technology/VUE2/router.md","localizedDate":"2025年3月10日","excerpt":"<h2> 前言</h2>\\n<p>传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。</p>\\n<h2> 前端路由</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">你对前端路由/vue-router的理解？ 前端路由/vue-router的实现原理？</p>\\n<p>前端路由是基于hash模式和history模式实现的。<br>\\nhash模式是通过监听浏览器的hashchange事件，当浏览器hash值（锚点#）部分发生变化，做出相应渲染。<br>\\n优点：1.兼容性好，大部分浏览器都支持；2.不需要后端配合<br>\\n缺点：1.外观上带#号；2.影响seo搜索<br>\\nhistory模式是使用html5推出的historyAPI，使用popstate来监听变化，pushState和replaceState来实现渲染。<br>\\n优点：1.有更符合浏览器链接的外观；2.利于seo搜索<br>\\n缺点：1.兼容性较差；2.需要后端配合，非则可能出现404错误</p>\\n</div>","autoDesc":true}');export{e as data};
